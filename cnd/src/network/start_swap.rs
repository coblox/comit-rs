use crate::{
    asset::Erc20,
    http_api::routes::HanEthereumHalightBitcoinCreatedState,
    network::{comit_ln, ComitNode},
    swap_protocols::{
        halight, halight::LndConnectorAsReceiver, herc20_rfc003_watcher, ledger,
        rfc003::create_swap::HtlcParams, LocalSwapId, Role,
    },
};
use tracing_futures::Instrument;

// TODO: Right now this trait is overkill but I believe it is at the right
// Level to allow addition of new protocol pairs
pub trait StartSwap<T> {
    fn start_swap(
        &mut self,
        local_swap_id: LocalSwapId,
        data: comit_ln::Data,
        create_swap_params: T,
    );
}

impl StartSwap<HanEthereumHalightBitcoinCreatedState> for ComitNode {
    fn start_swap(
        &mut self,
        local_swap_id: LocalSwapId,
        data: comit_ln::Data,
        remote_data: comit_ln::RemoteData,
        create_swap_params: HanEthereumHalightBitcoinCreatedState,
    ) {
        /// TODO this is the bridge between "pair" agnostic `ComitLn`
        /// and concret `new_*_swap` `SwapFinalized` is
        /// generated by `ComitLn`. Currently thinking that it should
        /// contain a "pair" specific object that can
        /// later be made generic easily. this would give this
        /// "pair" specific information (role, alpha ledger) to here
        /// without having ComitLn cater for it.
        let role = data.role;
        let params = halight::Params {
            identity: data.lightning_identity,
            cltv_expiry: data.lightning_cltv_expiry,
            amount: create_swap_params.lightning_amount,
            secret_hash: data.secret,
        };

        match self.lnd_connector_params {
            None => tracing::error!(
                "Internal Failure: lnd
                connectors are not initialised, no action has been taken.
                This should be unreachable."
            ),
            Some(ref lnd_connector_params) => match role {
                Role::Alice => {
                    tokio::task::spawn({
                        let lnd_connector: LndConnectorAsReceiver =
                            (**lnd_connector_params).clone().into();
                        halight::new_halight_swap(
                            local_swap_id,
                            params,
                            self.halight_states.clone(),
                            lnd_connector,
                        )
                        .instrument(
                            tracing::error_span!("beta_ledger", swap_id = %local_swap_id,
                role = %role),
                        )
                    });

                    tokio::task::spawn({
                        let connector = self.ethereum_connector.clone();
                        let alice_ethereum_identity = create_swap_params.ethereum_identity;
                        let bob_ethereum_identity = ethereum_identity;

                        let asset = create_swap_params.ethereum_amount;
                        let ledger = ledger::Ethereum::default();
                        let expiry = create_swap_params.ethereum_absolute_expiry;
                        let token_contract = create_swap_params.token_contract.into();
                        let erc20 = Erc20::new(token_contract, asset);

                        herc20_rfc003_watcher::new_herc20_swap(
                            local_swap_id,
                            connector,
                            self.alpha_ledger_states.clone(),
                            HtlcParams {
                                asset: erc20,
                                ledger,
                                redeem_identity: bob_ethereum_identity,
                                refund_identity: alice_ethereum_identity.into(),
                                expiry,
                                secret_hash,
                            },
                            role,
                        )
                    });
                }

                Role::Bob => {
                    tokio::task::spawn({
                        let lnd_connector: LndConnectorAsSender =
                            (**lnd_connector_params).clone().into();

                        self::halight::new_halight_swap(
                            local_swap_id,
                            params,
                            self.halight_states.clone(),
                            lnd_connector,
                        )
                        .instrument(
                            tracing::error_span!("beta_ledger", swap_id = %local_swap_id,
                role = %role),
                        )
                    });

                    tokio::task::spawn({
                        let connector = self.ethereum_connector.clone();
                        let alice_ethereum_identity = ethereum_identity;
                        let bob_ethereum_identity = create_swap_params.ethereum_identity;

                        let asset = create_swap_params.ethereum_amount.clone();
                        let ledger = ledger::Ethereum::default();
                        let expiry = create_swap_params.ethereum_absolute_expiry;
                        let token_contract = create_swap_params.token_contract.into();
                        let erc20 = Erc20::new(token_contract, asset);

                        self::herc20_rfc003_watcher::new_herc20_swap(
                            local_swap_id,
                            connector,
                            self.alpha_ledger_states.clone(),
                            HtlcParams {
                                asset: erc20,
                                ledger,
                                redeem_identity: bob_ethereum_identity.into(),
                                refund_identity: alice_ethereum_identity,
                                expiry,
                                secret_hash,
                            },
                            role,
                        )
                    });
                }
            },
        }
    }
}
